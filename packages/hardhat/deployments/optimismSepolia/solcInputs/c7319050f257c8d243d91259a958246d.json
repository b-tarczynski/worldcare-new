{
  "language": "Solidity",
  "sources": {
    "contracts/helpers/ByteHasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary ByteHasher {\n    /// @dev Creates a keccak256 hash of a bytestring.\n    /// @param value The bytestring to hash\n    /// @return The hash of the specified value\n    /// @dev `>> 8` makes sure that the result is included in our field\n    function hashToField(bytes memory value) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(value))) >> 8;\n    }\n}\n"
    },
    "contracts/interfaces/IWorldID.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IWorldID {\n    /// @notice Reverts if the zero-knowledge proof is invalid.\n    /// @param root The of the Merkle tree\n    /// @param groupId The id of the Semaphore group\n    /// @param signalHash A keccak256 hash of the Semaphore signal\n    /// @param nullifierHash The nullifier hash\n    /// @param externalNullifierHash A keccak256 hash of the external nullifier\n    /// @param proof The zero-knowledge proof\n    /// @dev  Note that a double-signaling check is not included here, and should be carried by the caller.\n    function verifyProof(\n        uint256 root,\n        uint256 groupId,\n        uint256 signalHash,\n        uint256 nullifierHash,\n        uint256 externalNullifierHash,\n        uint256[8] calldata proof\n    ) external view;\n}\n"
    },
    "contracts/WorldCare.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { ByteHasher } from \"./helpers/ByteHasher.sol\";\nimport { IWorldID } from \"./interfaces/IWorldID.sol\";\n\ncontract WorldCare {\n\t// address[] public patients;\n\t// address[] public doctors;\n\n\tstruct VisitDetails {\n\t\tuint price;\n\t\tbool paid;\n\t\taddress doctor;\n\t\taddress patient;\n\t}\n\n\tmapping(address => bool) public patients;\n\tmapping(address => bool) public doctors;\n\n\tmapping(string => VisitDetails) public visitdetails;\n\n\tmapping(address => mapping(address => bool)) public doctorsPermissions;\n\n\tusing ByteHasher for bytes;\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t///                                  ERRORS                                ///\n\t//////////////////////////////////////////////////////////////////////////////\n\n\t/// @notice Thrown when attempting to reuse a nullifier\n\terror InvalidNullifier();\n\n\t/// @dev The World ID instance that will be used for verifying proofs\n\tIWorldID internal immutable worldId;\n\n\t/// @dev The contract's external nullifier hash\n\tuint256 internal immutable externalNullifier;\n\n\t/// @dev The World ID group ID (always 1)\n\tuint256 internal immutable groupId = 1;\n\n\t/// @dev Whether a nullifier hash has been used already. Used to guarantee an action is only performed once by a single person\n\tmapping(uint256 => bool) internal nullifierHashes;\n\n\tevent DoctorRegistered(address indexed doctor, string filesCid);\n\tevent PatientRegistered(address indexed patient);\n\tevent VisitFinalized(\n\t\taddress indexed patient,\n\t\taddress indexed doctor,\n\t\tstring visitCid,\n\t\tuint price\n\t);\n\tevent TransactionPaid(string visitCid);\n\n\t/// @param _worldId The WorldID instance that will verify the proofs\n\t/// @param _appId The World ID app ID\n\t/// @param _actionId The World ID action ID\n\tconstructor(\n\t\tIWorldID _worldId,\n\t\tstring memory _appId,\n\t\tstring memory _actionId\n\t) {\n\t\tworldId = _worldId;\n\t\texternalNullifier = abi\n\t\t\t.encodePacked(abi.encodePacked(_appId).hashToField(), _actionId)\n\t\t\t.hashToField();\n\t}\n\n\t/// @param signal An arbitrary input from the user, usually the user's wallet address (check README for further details)\n\t/// @param root The root of the Merkle tree (returned by the JS widget).\n\t/// @param nullifierHash The nullifier hash for this proof, preventing double signaling (returned by the JS widget).\n\t/// @param proof The zero-knowledge proof that demonstrates the claimer is registered with World ID (returned by the JS widget).\n\t/// @dev Feel free to rename this method however you want! We've used `claim`, `verify` or `execute` in the past.\n\tfunction registerPatient(\n\t\taddress signal,\n\t\tuint256 root,\n\t\tuint256 nullifierHash,\n\t\tuint256[8] calldata proof\n\t) public {\n\t\t// First, we make sure this person hasn't done this before\n\t\tif (nullifierHashes[nullifierHash]) revert InvalidNullifier();\n\t\trequire(!patients[signal], \"Patient already registered\");\n\t\trequire(!doctors[signal], \"Doctor already registered\");\n\n\t\t// We now verify the provided proof is valid and the user is verified by World ID\n\t\tworldId.verifyProof(\n\t\t\troot,\n\t\t\tgroupId,\n\t\t\tabi.encodePacked(signal).hashToField(),\n\t\t\tnullifierHash,\n\t\t\texternalNullifier,\n\t\t\tproof\n\t\t);\n\n\t\t// We now record the user has done this, so they can't do it again (proof of uniqueness)\n\t\tnullifierHashes[nullifierHash] = true;\n\n\t\tpatients[signal] = true;\n\n\t\temit PatientRegistered(signal);\n\n\t\t// Finally, execute your logic here, for example issue a token, NFT, etc...\n\t\t// Make sure to emit some kind of event afterwards!\n\t}\n\n\t// function registerPatient() public {\n\t//     patients.push(msg.sender);\n\t// }\n\n\t/// @param signal An arbitrary input from the user, usually the user's wallet address (check README for further details)\n\t/// @param root The root of the Merkle tree (returned by the JS widget).\n\t/// @param nullifierHash The nullifier hash for this proof, preventing double signaling (returned by the JS widget).\n\t/// @param proof The zero-knowledge proof that demonstrates the claimer is registered with World ID (returned by the JS widget).\n\t/// @dev Feel free to rename this method however you want! We've used `claim`, `verify` or `execute` in the past.\n\tfunction registerDoctor(\n\t\taddress signal,\n\t\tuint256 root,\n\t\tuint256 nullifierHash,\n\t\tuint256[8] calldata proof,\n\t\tstring calldata filesCid\n\t) public {\n\t\t// First, we make sure this person hasn't done this before\n\t\tif (nullifierHashes[nullifierHash]) revert InvalidNullifier();\n\t\trequire(!patients[signal], \"Patient already registered\");\n\t\trequire(!doctors[signal], \"Doctor already registered\");\n\t\t// We now verify the provided proof is valid and the user is verified by World ID\n\t\tworldId.verifyProof(\n\t\t\troot,\n\t\t\tgroupId,\n\t\t\tabi.encodePacked(signal).hashToField(),\n\t\t\tnullifierHash,\n\t\t\texternalNullifier,\n\t\t\tproof\n\t\t);\n\n\t\t// We now record the user has done this, so they can't do it again (proof of uniqueness)\n\t\tnullifierHashes[nullifierHash] = true;\n\n\t\tdoctors[signal] = true;\n\n\t\temit DoctorRegistered(signal, filesCid);\n\n\t\t// Finally, execute your logic here, for example issue a token, NFT, etc...\n\t\t// Make sure to emit some kind of event afterwards!\n\t}\n\n\tfunction finalizeVisit(\n\t\taddress patient,\n\t\taddress doctor,\n\t\tstring calldata visitCid,\n\t\tuint price\n\t) public {\n\t\trequire(doctors[doctor], \"Only doctors can add documents\");\n\t\trequire(patients[patient], \"Only patients can have documents\");\n        require(doctorsPermissions[doctor][patient], \"Doctor does not have permission to access patient's profile\");\n\t\tvisitdetails[visitCid] = VisitDetails(price, false, doctor, patient);\n\t\temit VisitFinalized(patient, doctor, visitCid, price);\n\t}\n\n\tfunction shareProfile(address doctor) public {\n\t\trequire(doctors[doctor], \"Only doctors can be shared with\");\n\t\trequire(patients[msg.sender], \"Only patients can share their profile\");\n\t\tdoctorsPermissions[doctor][msg.sender] = true;\n\t}\n\n\tfunction revokeProfile(address doctor) public {\n\t\trequire(doctors[doctor], \"Only doctors can be shared with\");\n\t\trequire(patients[msg.sender], \"Only patients can share their profile\");\n\t\tdoctorsPermissions[doctor][msg.sender] = false;\n\t}\n\n\tfunction payForVisit(string calldata visitCid) public payable {\n\t\trequire(patients[msg.sender], \"Only patients can pay for visits\");\n\t\trequire(\n\t\t\tvisitdetails[visitCid].patient == msg.sender,\n\t\t\t\"Only the patient can pay for the visit\"\n\t\t);\n\t\trequire(\n\t\t\tvisitdetails[visitCid].paid == false,\n\t\t\t\"The visit has already been paid for\"\n\t\t);\n\t\trequire(visitdetails[visitCid].price == msg.value, \"Bad value\");\n\t\t// Transfer the payment to the doctor\n\t\tpayable(visitdetails[visitCid].doctor).transfer(msg.value);\n\t\t// Mark the visit as paid\n\t\tvisitdetails[visitCid].paid = true;\n\t\trevokeProfile(visitdetails[visitCid].doctor);\n\t\temit TransactionPaid(visitCid);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}